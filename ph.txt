keyholder.push(data[key]);
                for(let i = 0; i < data[key].length; i++) {
                    modArr.push(i);
                }
                modArr.push("Q"); //extra end value for functionality

                let index = modArr.indexOf(0);
                for(let i = 0; i < countOccur(modArr, 0); i++) {
                    na.push(modArr.slice(index, modArr.indexOf(0,index+1)));
                    index = modArr.indexOf(0, index+1);
                }
                //start changing text content
                let idsToFill = spliceArray(idtp, na);
                if(idsToFill.length === na.length) {
                    // console.log(na);
                    // console.log(idsToFill);
                    for(let i = 0; i < idsToFill.length; i++) {
                        if(idsToFill[i].length == na[i].length) {
                            console.log("idstofill[i] is same as na[i] in length");
                            // for(let j = 0; j < idsToFill[i].length; j++) {
                            //     // idsToFill[i][j].innerText = "new value : "+ data[key][i].trainId;
                            //     console.log(data[key]);
                            // }
                        } else if(na[i].length > idsToFill[i].length) {
                            console.log("na is grater than ids");
                            idsToFill = spliceArray(idtp, na);
                        }
                    }
                } else {
                    console.log("so far not good");
                }


                let allnodes = removeDivide();
                let ttda = spliceArray(allnodes, na);

                let dividers = [...document.querySelectorAll(".divide")];
                let allChildren = [...maintab.children];
                allChildren.shift();
                let temp_indices = dividers.map((divider) => allChildren.indexOf(divider));

                if(ttda.length == temp_indices.length && ttda.length == na.length) {
                    let intervals = resetIntervals(temp_indices, na, allChildren);
                    //ttda will sometimes be shorter because it is derived from na
                    //na is directly making a count of realtime data
                    //let ttda be the deciding factor in intervals change
                    console.log(na);
                    console.log(intervals);
                    if(na.length == intervals.length) {
                        for(let i = 0; i < intervals.length; i++) {
                            if(na[i].length < intervals[i].length) {
                                let toErase;
                                let diff = intervals[i].length - na[i].length;
                                // console.log(na[i]);
                                // console.log(intervals[i]);
                                // if(na[i].length > intervals[i].length) {
                                //     intervals[i].splice(0, 0, erased);
                                //     intervals[i].join();
                                // }
                            }
                            console.log("/////////////////////////////////////////");
                        }
                    } else {
                        console.log("ttda: "+ttda.length + " != " + "intervals: " + intervals.length);
                    }
                }