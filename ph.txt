let idtp = [...document.querySelectorAll(".pid")];
            let stoptp = document.getElementsByClassName("stop");
            let timetp = document.getElementsByClassName("time");

            let modArr = [];
        var na = [];
        let keyholder = [];

keyholder.push(data[key]);
                for(let i = 0; i < data[key].length; i++) {
                    modArr.push(i);
                }
                modArr.push("Q"); //extra end value for functionality

                let index = modArr.indexOf(0);
                for(let i = 0; i < countOccur(modArr, 0); i++) {
                    na.push(modArr.slice(index, modArr.indexOf(0,index+1)));
                    index = modArr.indexOf(0, index+1);
                }
                //start changing text content
                let idsToFill = spliceArray(idtp, na);
                if(idsToFill.length === na.length) {
                    // console.log(na);
                    // console.log(idsToFill);
                    for(let i = 0; i < idsToFill.length; i++) {
                        if(idsToFill[i].length == na[i].length) {
                            console.log("idstofill[i] is same as na[i] in length");
                            // for(let j = 0; j < idsToFill[i].length; j++) {
                            //     // idsToFill[i][j].innerText = "new value : "+ data[key][i].trainId;
                            //     console.log(data[key]);
                            // }
                        } else if(na[i].length > idsToFill[i].length) {
                            console.log("na is grater than ids");
                            idsToFill = spliceArray(idtp, na);
                        }
                    }
                } else {
                    console.log("so far not good");
                }


                let allnodes = removeDivide();
                let ttda = spliceArray(allnodes, na);

                let dividers = [...document.querySelectorAll(".divide")];
                let allChildren = [...maintab.children];
                allChildren.shift();
                let temp_indices = dividers.map((divider) => allChildren.indexOf(divider));

                if(ttda.length == temp_indices.length && ttda.length == na.length) {
                    let intervals = resetIntervals(temp_indices, na, allChildren);
                    //ttda will sometimes be shorter because it is derived from na
                    //na is directly making a count of realtime data
                    //let ttda be the deciding factor in intervals change
                    console.log(na);
                    console.log(intervals);
                    if(na.length == intervals.length) {
                        for(let i = 0; i < intervals.length; i++) {
                            if(na[i].length < intervals[i].length) {
                                let toErase;
                                let diff = intervals[i].length - na[i].length;
                                // console.log(na[i]);
                                // console.log(intervals[i]);
                                // if(na[i].length > intervals[i].length) {
                                //     intervals[i].splice(0, 0, erased);
                                //     intervals[i].join();
                                // }
                            }
                            console.log("/////////////////////////////////////////");
                        }
                    } else {
                        console.log("ttda: "+ttda.length + " != " + "intervals: " + intervals.length);
                    }
                }


const countOccur = (arr, value) => {
    return arr.reduce((a, val) => (val === value ? a + 1 : a), 0);
}
function spliceArray(idtp, na) {
    let spliced = [];
    for(let j = 0; j < na.length; j++) {
        spliced.push(idtp.splice(0, na[j].length)); 
    }
    return spliced;
} 

function removeDivide() {
    let top = document.getElementById("placehold");
    let dividers = [...document.querySelectorAll(".divide")];
    let allChildren = [...maintab.children];
    allChildren.shift();
    
    let temp_indices = dividers.map((divider) => allChildren.indexOf(divider));
    const removeItem = (items, i) => items.slice(0, i-1).concat(items.slice(i, items.length));

    let init = removeItem(allChildren, temp_indices[0]+1);
    while(temp_indices.length != 0) {
        temp_indices.shift();
        temp_indices = temp_indices.map(val => val -= 1);
        init = removeItem(init, temp_indices[0]+1);
    }
    return init;
}
function resetIntervals(temp_indices, na, allChildren) {
    //intervals of stops between next stop and last stop, inclusive
    let intervals = [];
    let interval = allChildren.slice(0, temp_indices[0]); 
    for(let i = 0; i < na.length; i++) {
        intervals.push(interval);
        interval = allChildren.slice(temp_indices[i]+1, temp_indices[i+1]);
    }
    return intervals;
}